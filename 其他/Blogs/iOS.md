<<<<<<< HEAD
#Block 的存储域
Block 有三种类型，分别是：

`__NSConcreteStackBlock ————————栈中`
`__NSConcreteGlobalBlock ————————数据区域中`
`__NSConcreteMallocBlock ————————堆中`


#__unsafe_unretained作用
那么为什么你还要使用__unsafe_unretained?不幸的是，__weak只支持iOS 5.0和OS X Mountain Lion作为部署版本。如果你想部署回iOS 4.0和OS X Snow Leopark，你就不得不用__unsafe_unretained标识符，或者用一些其他东西，就像Mike Ash的


#load和initialize
1. load和initialize的共同特点

load和initialize有很多共同特点，下面简单列一下：

在不考虑开发者主动使用的情况下，系统最多会调用一次

如果父类和子类都被调用，父类的调用一定在子类之前

都是为了应用运行提前创建合适的运行环境

在使用时都不要过重地依赖于这两个方法，除非真正必要

2. load方法相关要点

废话不多说，直接上要点列表：

调用时机比较早，运行环境有不确定因素。具体说来，在iOS上通常就是App启动时进行加载，但当load调用的时候，并不能保证所有类都加载完成且可用，必要时还要自己负责做auto release处理。

补充上面一点，对于有依赖关系的两个库中，被依赖的类的load会优先调用。但在一个库之内，调用顺序是不确定的。

对于一个类而言，没有load方法实现就不会调用，不会考虑对NSObject的继承。

一个类的load方法不用写明[super load]，父类就会收到调用，并且在子类之前。

Category的load也会收到调用，但顺序上在主类的load调用之后。

不会直接触发initialize的调用。

3. initialize方法相关要点

同样，直接整理要点：

initialize的自然调用是在第一次主动使用当前类的时候（lazy，这一点和Java类的“clinit”的很像）。

在initialize方法收到调用时，运行环境基本健全。

initialize的运行过程中是能保证线程安全的。

和load不同，即使子类不实现initialize方法，会把父类的实现继承过来调用一遍。注意的是在此之前，父类的方法已经被执行过一次了，同样不需要super调用。


# 什么是反射机制
Java的反射机制的实现要借助于4个类：class，Constructor，Field，Method;

其中class代表的时类对 象，Constructor－类的构造器对象，Field－类的属性对象，Method－类的方法对象。通过这四个对象我们可以粗略的看到一个类的各个组 成部分。

Java反射的作用：在Java运行时环境中，对于任意一个类，可以知道这个类有哪些属性和方法。对于任意一个对象，可以调用它的任意一个方法。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java 语言的反射（Reflection）机制。

Java 反射机制主要提供了以下功能在运行时判断任意一个对象所属的类。

在运行时构造任意一个类的对象。

在运行时判断任意一个类所具有的成员变量和方法。

在运行时调用任意一个对象的方法

反射的常用类和函数:Java反射机制的实现要借助于4个类：Class，Constructor，Field，Method；



# 什么是程序计数器
程序计数器是用于存放下一条指令所在单元的地址的地方。当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行
=======
* [Offer](https://github.com/xuelangZF/CS_Offer/tree/master/Offer)
* [The-Art-Of-Programming-By-July](https://github.com/julycoding/The-Art-Of-Programming-By-July)
* [load和initialize](https://www.jianshu.com/p/71e25032e338)

# 为什么说Objective-C是一门动态的语言？
动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化。比如Ruby、Python等就是动态语言，而C、C++等语言则不属于动态语言。

Dynamically Typed Language (动态类型语言)

Objective-C的动态性让程序可以在运行时判断其该有的行为，而不是像C等静态语言一样在编译构建时就确定下来。它的动态性主要体现在一下三个方面：

1、动态类型。 如id类型。实际上静态类型因为其固定性和可预知性而使用得更加广泛。静态类型是强类型，而动态类型属于弱类型。运行时决定接收者。

2、 动态绑定。让代码在运行时判断需要调用什么方法，而不是在编译时。与其他面向对象语言一样，方法调用和代码并没有在编译时连接在一起，而是在消息发送时才进行连接。运行时决定调用哪个方法。

3、 动态载入。让程序在运行时添加代码模块以及其他资源。用户可以根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件。可执行代码中可以含有和程序运行时整合的新类。

对象是运行时类的一个实例。在类里声明了的实例变量和方法，它的每个实例都在内存中拥有同样的实例变量，以及指向那些方法的指针。在Objective-C中对象永远是通过指针来引用的。


# NSNotification、Block、Delegate和KVO的区别

代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知；

效率：Delegate比NSNOtification高；

Delegate和Block一般是一对一的通信；

Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信；

Block ： Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate；

# OC的理解与特性
OC作为一门面向对象的语言，自然具有面向对象的语言特性：封装、继承、多态。它既具有静态语言的特性（如C++），又有动态语言的效率（动态绑定、动态加载等）。总体来讲，OC确实是一门不错的编程语言。

Objective-C具有相当多的动态特性，表现为三方面：动态类型（Dynamic typing）、动态绑定（Dynamic binding）和动态加载（Dynamic loading）。动态——必须到运行时（run time）才会做的一些事情。

# 享元模式
享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。

享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。

享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。

* 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。
* 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。

### 适用环境
在以下情况下可以使用享元模式：

一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。
对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。
优点 & 缺点
### 优点
享元模式的优点

享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。
享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。
### 缺点
享元模式的缺点

享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。

# 关于@encode
意义：@编译器指令 之一，返回一个给定类型编码为一种内部表示的字符串（例如，@encode(int) → i），类似于 ANSI C 的 typeof 操作。苹果的 Objective-C 运行时库（runtime）内部利用类型编码帮助加快消息分发。

# 什么是NSValue？
* NSNumber是NSValue的子类, 但NSNumber只能包装数字类型
* NSValue可以包装任意值
* 因此, 可以用NSValue将结构体包装后, 加入NSArray\NSDictionary中

1.由于集合里只能存放对象，不可以存放基本数据类型,所以我们有时候需要讲一些对象比如基本数据类型，结构体等存到NSDictionary NSArray中，我们就需要将这些数据类型或结构体包装成OC对象，以便集合能访问到。常用的用来包装这些类型的有NSNumber NSValue

2.NSNumber只能包装基本数据类型，比如int, float,char,BOOL等

3.NSValue可以包装任意一个对象，包括系统自定义的数据结构，结构体等等

4.NSNumber是NSValue的一个子类

>>>>>>> 9ccb2875d943ce2bf03914b54c9aa4755bfd116f

# iOS常用的动画
UIView动画，核心动画，帧动画，自定义转场动画

Spring动画
ios7.0以后新增了Spring动画(IOS系统动画大部分采用Spring Animation， 适用所有可被添加动画效果的属性)

UIView是用来显示内容的，可以处理用户事件

CALayer是用来绘制内容的，对内容进行动画处理依赖与UIView来进行显示，不能处理用户事件。

UIView主要是对显示内容的管理而 CALayer 主要侧重显示内容的绘制。

# iOS系统的signal可以被归为两类

**第一类内核signal**，这类signal由操作系统内核发出，比如当我们访问VM上不属于自己的内存地址时，会触发EXC_BAD_ACCESS异常，内核检测到该异常之后会发出第二类signal：BSD signal，传递给应用程序。

**第二类BSD signal**，这类signal需要被应用程序自己处理。通常当我们的App进程运行时遇到异常，比如NSArray越界访问。产生异常的线程会向当前进程发出signal，如果这个signal没有别处理，我们的app就会crash了。

平常我们调试的时候很容易遇到第二类signal导致整个程序被中断的情况，gdb同时会将每个线程的调用栈呈现出来。


# iOS内核
iOS 是基于 Apple Darwin 内核，由 kernel、XNU 和 Runtime 组成，而 XNU 是 Darwin 的内核，它是“X is not UNIX”的缩写，是一个混合内核，由 Mach 微内核和 BSD 组成。Mach 内核是轻量级的平台，只能完成操作系统最基本的职责，比如：进程和线程、虚拟内存管理、任务调度、进程通信和消息传递机制。其他的工作，例如文件操作和设备访问，都由 BSD 层实现。


# 合理的线程分配
由于 GCD 实在太方便了，如果不加控制，大部分需要抛到子线程操作都会被直接加到 global 队列，这样会导致两个问题，1.开的子线程越来越多，线程的开销逐渐明显，因为开启线程需要占用一定的内存空间（默认的情况下，主线程占1M,子线程占用512KB）。2.多线程情况下，网络回调的时序问题，导致数据处理错乱，而且不容易发现。为此，我们项目定了一些基本原则。

UI 操作和 DataSource 的操作一定在主线程。
DB 操作、日志记录、网络回调都在各自的固定线程。
不同业务，可以通过创建队列保证数据一致性。例如，想法列表的数据加载、书籍章节下载、书架加载等。
合理的线程分配，最终目的就是保证主线程尽量少的处理非UI操作，同时控制整个App的子线程数量在合理的范围内。

# NSTimer属性tolerance
在NSTimer的头文件中，苹果新增了一个属性，叫做tolerance,我们可以理解为容差。苹果的意思是如果设定了tolerance值，那么:

设定时间 <= NSTimer的启动时间 <= 设定时间 + tolerance


# 动画
为了不阻塞主线程，Core Animation 的核心是 OpenGL ES 的一个抽象物，所以大部分的渲染是直接提交给GPU来处理。 而Core Graphics/Quartz 2D的大部分绘制操作都是在主线程和CPU上同步完成的，比如自定义UIView的drawRect里用CGContext来画图。

# load加载顺序
加载顺序是父类先+load，然后子类+load，然后分类+load

# 分类category能重新方法吗
一般重载了就不会调用主类里的方法，因为分类的的load是在主类后加载，实际调用时，调用的是后添加的方法，即后添加的方法在方法列表methodLists的这个数组的顶部

答案已经很明确了：后+load的类的方法，后添加到方法列表，而这时的添加方式又是插入顶部添加，即[methodLists insertObject:category_method atIndex:0]; 所以objc_msgSend遍历方法列表查找SEL 对应的IMP时，会先找到分类重写的那个，调用执行。然后添加到缓存列表中，这样主类方法实现永远也不会调到。

但是分类UIViewController中，会先调用分类的viewDidLoad方法，然后再调用主类的viewDidLoad方法

多个category实现同一个方法
答案是：对于多个分类同时重写同一个方法，Xcode在运行时是根据buildPhases->Compile Sources里面的顺序从上至下编译的，那么很明显就像子类和分类一样，后编译的后load，即后添加到方法列表，所以后编译的分类，方法会放到方法列表顶部，调用的时候先执行。

总结一句话：类的加载顺序，决定方法的添加顺序，调用的时候，后添加的方法会先被找到，所以调用的始终是后加载的类的方法实现。


