* [Offer](https://github.com/xuelangZF/CS_Offer/tree/master/Offer)
* [The-Art-Of-Programming-By-July](https://github.com/julycoding/The-Art-Of-Programming-By-July)
* [load和initialize](https://www.jianshu.com/p/71e25032e338)

# 为什么说Objective-C是一门动态的语言？
动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化。比如Ruby、Python等就是动态语言，而C、C++等语言则不属于动态语言。

Dynamically Typed Language (动态类型语言)

Objective-C的动态性让程序可以在运行时判断其该有的行为，而不是像C等静态语言一样在编译构建时就确定下来。它的动态性主要体现在一下三个方面：

1、动态类型。 如id类型。实际上静态类型因为其固定性和可预知性而使用得更加广泛。静态类型是强类型，而动态类型属于弱类型。运行时决定接收者。

2、 动态绑定。让代码在运行时判断需要调用什么方法，而不是在编译时。与其他面向对象语言一样，方法调用和代码并没有在编译时连接在一起，而是在消息发送时才进行连接。运行时决定调用哪个方法。

3、 动态载入。让程序在运行时添加代码模块以及其他资源。用户可以根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件。可执行代码中可以含有和程序运行时整合的新类。

对象是运行时类的一个实例。在类里声明了的实例变量和方法，它的每个实例都在内存中拥有同样的实例变量，以及指向那些方法的指针。在Objective-C中对象永远是通过指针来引用的。


# NSNotification、Block、Delegate和KVO的区别

代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知；

效率：Delegate比NSNOtification高；

Delegate和Block一般是一对一的通信；

Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信；

Block ： Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate；

# OC的理解与特性
OC作为一门面向对象的语言，自然具有面向对象的语言特性：封装、继承、多态。它既具有静态语言的特性（如C++），又有动态语言的效率（动态绑定、动态加载等）。总体来讲，OC确实是一门不错的编程语言。

Objective-C具有相当多的动态特性，表现为三方面：动态类型（Dynamic typing）、动态绑定（Dynamic binding）和动态加载（Dynamic loading）。动态——必须到运行时（run time）才会做的一些事情。

# 享元模式
享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。

享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。

享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。

* 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。
* 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。

### 适用环境
在以下情况下可以使用享元模式：

一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。
对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。
优点 & 缺点
### 优点
享元模式的优点

享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。
享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。
### 缺点
享元模式的缺点

享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。

# 关于@encode
意义：@编译器指令 之一，返回一个给定类型编码为一种内部表示的字符串（例如，@encode(int) → i），类似于 ANSI C 的 typeof 操作。苹果的 Objective-C 运行时库（runtime）内部利用类型编码帮助加快消息分发。

# 什么是NSValue？
* NSNumber是NSValue的子类, 但NSNumber只能包装数字类型
* NSValue可以包装任意值
* 因此, 可以用NSValue将结构体包装后, 加入NSArray\NSDictionary中

1.由于集合里只能存放对象，不可以存放基本数据类型,所以我们有时候需要讲一些对象比如基本数据类型，结构体等存到NSDictionary NSArray中，我们就需要将这些数据类型或结构体包装成OC对象，以便集合能访问到。常用的用来包装这些类型的有NSNumber NSValue

2.NSNumber只能包装基本数据类型，比如int, float,char,BOOL等

3.NSValue可以包装任意一个对象，包括系统自定义的数据结构，结构体等等

4.NSNumber是NSValue的一个子类


# iOS常用的动画
UIView动画，核心动画，帧动画，自定义转场动画

Spring动画
ios7.0以后新增了Spring动画(IOS系统动画大部分采用Spring Animation， 适用所有可被添加动画效果的属性)

UIView是用来显示内容的，可以处理用户事件

CALayer是用来绘制内容的，对内容进行动画处理依赖与UIView来进行显示，不能处理用户事件。

UIView主要是对显示内容的管理而 CALayer 主要侧重显示内容的绘制。

# iOS系统的signal可以被归为两类

**第一类内核signal**，这类signal由操作系统内核发出，比如当我们访问VM上不属于自己的内存地址时，会触发EXC_BAD_ACCESS异常，内核检测到该异常之后会发出第二类signal：BSD signal，传递给应用程序。

**第二类BSD signal**，这类signal需要被应用程序自己处理。通常当我们的App进程运行时遇到异常，比如NSArray越界访问。产生异常的线程会向当前进程发出signal，如果这个signal没有别处理，我们的app就会crash了。

平常我们调试的时候很容易遇到第二类signal导致整个程序被中断的情况，gdb同时会将每个线程的调用栈呈现出来。


# iOS内核
iOS 是基于 Apple Darwin 内核，由 kernel、XNU 和 Runtime 组成，而 XNU 是 Darwin 的内核，它是“X is not UNIX”的缩写，是一个混合内核，由 Mach 微内核和 BSD 组成。Mach 内核是轻量级的平台，只能完成操作系统最基本的职责，比如：进程和线程、虚拟内存管理、任务调度、进程通信和消息传递机制。其他的工作，例如文件操作和设备访问，都由 BSD 层实现。


# 合理的线程分配
由于 GCD 实在太方便了，如果不加控制，大部分需要抛到子线程操作都会被直接加到 global 队列，这样会导致两个问题，1.开的子线程越来越多，线程的开销逐渐明显，因为开启线程需要占用一定的内存空间（默认的情况下，主线程占1M,子线程占用512KB）。2.多线程情况下，网络回调的时序问题，导致数据处理错乱，而且不容易发现。为此，我们项目定了一些基本原则。

UI 操作和 DataSource 的操作一定在主线程。
DB 操作、日志记录、网络回调都在各自的固定线程。
不同业务，可以通过创建队列保证数据一致性。例如，想法列表的数据加载、书籍章节下载、书架加载等。
合理的线程分配，最终目的就是保证主线程尽量少的处理非UI操作，同时控制整个App的子线程数量在合理的范围内。

# NSTimer属性tolerance
在NSTimer的头文件中，苹果新增了一个属性，叫做tolerance,我们可以理解为容差。苹果的意思是如果设定了tolerance值，那么:

设定时间 <= NSTimer的启动时间 <= 设定时间 + tolerance


# 动画
为了不阻塞主线程，Core Animation 的核心是 OpenGL ES 的一个抽象物，所以大部分的渲染是直接提交给GPU来处理。 而Core Graphics/Quartz 2D的大部分绘制操作都是在主线程和CPU上同步完成的，比如自定义UIView的drawRect里用CGContext来画图。