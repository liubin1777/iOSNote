# 取地址(&)和内容引用(*)的区别

`&`是取地址运算符，`&a`为变量`a`的地址。

`* `是指针运算符，`*p`为指针变量`p`所指向的存储单元中的内容, 而指针变量`p`中一般只存放地址。

`指针变量所占的字节数，只与操作系统的位数有关，64位环境下占8字节，32为环境下占4字节`


# 汇编学习之函数调用栈
程序的执行过程可看作连续的函数调用。当一个函数执行完毕时，程序要回到调用指令的下一条指令(紧接call指令)处继续执行。函数调用过程通常使用堆栈实现，每个用户态进程对应一个调用栈结构(call stack)。编译器使用堆栈传递函数参数、保存返回地址、临时保存寄存器原有值(即函数调用的上下文)以备恢复以及存储本地局部变量。

不同处理器和编译器的堆栈布局、函数调用方法都可能不同，但堆栈的基本概念是一样的。

# 首先符号表是什么？

符号表储存在 Mach-O 文件的 `__LINKEDIT` 段中，涉及其中的符号表（Symbol Table）和字符串表（String Table）。符号表在 Mach-O目标文件中的地址可以通过LC_SYMTAB加载命令指定的 symoff找到，对应的符号名称在stroff，总共有nsyms条符号信息；也就是说，通过LC_SYMTAB来找存储在__LINKEDIT中的符号地址地址；

那么我们首先要通过`__LINKEDIT`寻址，把该段的地址都找出来，这样就可以通过LC_SYMTAB来定位符号信息了，通过__LINKEDIT寻找镜像地址可以看我的另一篇博客Mach-O学习;

补充： 所有的符号地址全部存储在__LINKEDIT段中（注意是地址），所有的符号和字符串以及字符串对应符号所对应的函数指针（保存为一个结构体nlist，下面会讲到）都存在LC_SYMTAB加载命令区中。

