# OS X 内核
Darwin是操作系统的类UNIX核心，本身由内核（kernel），XNU（‘X’ is Not UNIX 的缩写），runtime运行时组成。Darwin是开源的

### XNU
内核XNU是Darwin 的核心，也是整个OS X 的核心。XNU由一下几个组件组成：

### Mach 微内核
进程和线程抽象
虚拟内存管理
任务调度
进程间通讯和消息传递机制
### BSD层
BSD层建立在Mach之上是一个很可靠且更现代的API，提供POSIX 兼容性。
BSD层提供更高层的抽象：
UNIX 进程模型
POSIX线程模型（Pthread）及相关的同步原语
UNIX 用户和组
网络协议栈（BSD Socket API）
文件系统访问
设备访问（通过/dev目录访问）
libKern
内核是C语言和汇编语言编写；I/OKit是C++ 编写的；为了支持C++运行时并提供所需要的基类，libKern库是一个內建的自包含的C++库。
I/O Kit
这是一个在内核中的完整的自包含的执行环境，让开发者可以快速创建优雅稳定的设备驱动程序。
### 系统调用
### POSIX
POSIX 兼容性是由XNU中BSD层提供的。
系统调用原型：所有的POSIX 系统调用（不论底层实现如何）都有相同的原型，也就是说具有相同的参数和返回值。
系统调用编号：除了固定的原型之外，POSIX还完整定义了系统调用的编号。
### Mach 系统调用
BSD层是对Mach内核的包装，但是Mach系统调用仍然可以在用户态访问。
在32位系统上，Mach系统调用的编号都为负数，POSIX调用编号为非负。
在64位系统上，Mach系统调用为正数，但是以0x2000000开头，而POSIX调用编号以0x1000000开头。

# 取地址(&)和内容引用(*)的区别

`&`是取地址运算符，`&a`为变量`a`的地址。

`* `是指针运算符，`*p`为指针变量`p`所指向的存储单元中的内容, 而指针变量`p`中一般只存放地址。

`指针变量所占的字节数，只与操作系统的位数有关，64位环境下占8字节，32为环境下占4字节`


# 汇编学习之函数调用栈
程序的执行过程可看作连续的函数调用。当一个函数执行完毕时，程序要回到调用指令的下一条指令(紧接call指令)处继续执行。函数调用过程通常使用堆栈实现，每个用户态进程对应一个调用栈结构(call stack)。编译器使用堆栈传递函数参数、保存返回地址、临时保存寄存器原有值(即函数调用的上下文)以备恢复以及存储本地局部变量。

不同处理器和编译器的堆栈布局、函数调用方法都可能不同，但堆栈的基本概念是一样的。

# 首先符号表是什么？

符号表储存在 Mach-O 文件的 `__LINKEDIT` 段中，涉及其中的符号表（Symbol Table）和字符串表（String Table）。符号表在 Mach-O目标文件中的地址可以通过LC_SYMTAB加载命令指定的 symoff找到，对应的符号名称在stroff，总共有nsyms条符号信息；也就是说，通过LC_SYMTAB来找存储在__LINKEDIT中的符号地址地址；

那么我们首先要通过`__LINKEDIT`寻址，把该段的地址都找出来，这样就可以通过LC_SYMTAB来定位符号信息了，通过__LINKEDIT寻找镜像地址可以看我的另一篇博客Mach-O学习;

补充： 所有的符号地址全部存储在__LINKEDIT段中（注意是地址），所有的符号和字符串以及字符串对应符号所对应的函数指针（保存为一个结构体nlist，下面会讲到）都存在LC_SYMTAB加载命令区中。

